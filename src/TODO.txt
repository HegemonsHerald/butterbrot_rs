
=====================================
FIX ALL THE TODOS THAT ARE EVERYWHERE
=====================================



ERROR HANDLING MACRO
====================

figure out how to properly share this between the modules!


Adding the actual mathematics into the math module...
=====================================================

Args_Parser
===========

  - supported flags
	
	--iterations	-i	iterations for each orbit
	--samples	-s	how many orbits to compute; optional if a timeout was provided
	--timeout	-t	optional timeout for the computation
	--out		-o	filename for birb output
	--width		-w	width for the buffer
	--height	-h	height for the buffer
	--complex1 r i	-c1 r i	one of the complex numbers dilimiting the frame to compute in, r and i being the real and imag parts
	--complex2 r i	-c2 r i	one of the complex numbers dilimiting the frame to compute in, r and i being the real and imag parts

  - the default for the thread_count is going to take some testing,
    with dummy computations 8 threads total, so thread_count = 7, seems to be quite alright (though not necessarily
    for sustained computation), but with the actual math needing to be done, this might have to be lowered

  - parse_args(args_v) does sth like this: setup the output tuple, call iter on args, then loop indefinitely
    on each loop, get the next argument, parse it using match against the flags, handle each flag appropriately
      appropriately means, possibly get the next arg and match that against pattern or &str::parse() it or sth,
      possibly even do that multiple times
      OR exit(1) with a suitable error message

Write_Back
==========

  - inside lib:: we'll have functions to do all of this...
  	- literally just lib::write_back(orbit:&Vec<u64>, supreme:&mut MutexLock)

  - Vec<u64>::with_capacity() and init counters to 0
  - vec[(imaginairy / step_size).floor() + (real / step_size).floor()] += 1


Termination Settings
====================

  - you specify the number of samples to compute

  - you optionally specify a timeout after which the program will definitely terminate, whether it's done or not

  - if you only specify a timeout, the args_parser sets the sample number to integer_max so that as many samples
    as possible will be computed

  - if you don't specify a timeout, the args_parser doesn't set the timeout flag, so the timeout will be ignored

    let (timeout, runtime, samples) = args_parser(args_v);

    where timeout = true if timeout setting was specified
	  runtime = the number of seconds (?) to terminate after, if timeout is true
	  samples = the number of samples to compute


Logging output
==============

  - main keeps a receiver of a channel
  - main keeps a stopwatch running, about the elapsed time
  - each thread gets a sender to that receiver

  - after each write_back the threads send a tuple with the thread's unique id and the number of samples left in it's MHOrbits-Iterator

  - main keeps a list of messages as long as the number of threads there is
  - every time main receives a message, it puts the number of samples into the id-position of the thread in the messages list
  - every time each position of the list is filled, main empties the message queue and produces following logging-output:

      thread 1 { total: NN, done: NN, left: NN, percent: NN% }
      thread 2 { total: NN, done: NN, left: NN, percent: NN% }
      thread 3 { total: NN, done: NN, left: NN, percent: NN% }
      thread 4 { total: NN, done: NN, left: NN, percent: NN% }
      thread 5 { total: NN, done: NN, left: NN, percent: NN% }
      thread 6 { total: NN, done: NN, left: NN, percent: NN% }
      thread 7 { total: NN, done: NN, left: NN, percent: NN% }
      thread 8 { total: NN, done: NN, left: NN, percent: NN% }

      samples done / total:   NN/NN
      percentage done:	      NN%
      time elapsed:	      NNs
      left / maximum runtime: NNs / NNs   (optional, depends on timeout setting)

  - the percentages can easily be computed from main, cause main knows how many samples each thread has to work on from originally creating the threads

  - the logging function only empties those msg from its queue, that don't contain the count 0, and when all counts are 0, it returns! (or after the timeout has elapsed)

  - after whole operation is done, before shutdown yield another log-message with the final data, and the filename,
    that was written and whatnot.
