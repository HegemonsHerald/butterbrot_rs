THE birb2bmp TOOL
=================

  - load a birb from file <- args_parser variant
  - split it into thread slices <- unsafe
  - find the largest number from the birb in parallel

  - what's the best approach to create the bitmap...?
     - single threadedly just compute
     - multi threaded: replace all the numbers in the birb with their 256 mapped counterparts?, then either use linear write or a mutex or something...
     - multi threaded: separate tinier bitmaps to merge into one larger one?    <- Can you do that?
     - multi threaded: one large bitmap with unsafe mutable concurrent slicing? <- Can you do that? This would be the BEST


=====================================
FIX ALL THE TODOS THAT ARE EVERYWHERE
=====================================

  - make the defaults and the help text align

Adding the actual mathematics into the math module...
=====================================================

Write_Back
==========

  - inside lib:: we'll have functions to do all of this...
  	- literally just lib::write_back(orbit:&Vec<u64>, supreme:&mut MutexLock)
        - Vec<u64>::with_capacity() and init counters to 0

  - vec[(imaginairy / step_size).floor() + (real / step_size).floor()] += 1


Logging output
==============

  - after whole operation is done, before shutdown yield another log-message with the final data, and the filename,
    that was written and whatnot.
