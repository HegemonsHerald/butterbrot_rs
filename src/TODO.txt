THE birb2bmp TOOL
=================

  - load a birb from file <- args_parser variant
  - split it into thread slices <- unsafe
  - find the largest number from the birb in parallel

  - what's the best approach to create the bitmap...?
     - single threadedly just compute
     - multi threaded: replace all the numbers in the birb with their 256 mapped counterparts?, then either use linear write or a mutex or something...
     - multi threaded: separate tinier bitmaps to merge into one larger one?    <- Can you do that?
     - multi threaded: one large bitmap with unsafe mutable concurrent slicing? <- Can you do that? This would be the BEST


=====================================
FIX ALL THE TODOS THAT ARE EVERYWHERE
=====================================

  - make the defaults and the help text align


Fixing the mathematics from the math module...
==============================================

  - Checking, whether the very last number is in or out, massively affects the result.
    This is quite strange and should be explored (and possibly fixed) using birb2img.
    Hypothesis: the double check, that an orbit is in or out, makes a huge difference for short orbits.
    That seems to be it, indeed.
    Which version is the "true" Buddhabrot set will be revealed by birb2img...


Args_Parser
===========

Consider allowing for the (as it seems) common input mode:

provide an anchor point, width, height and a zoom factor.

The inverse of the zoom factor is the step_size, so you can just go:

step_size = (1/zoom, 1/zoom)
other_point = { point.r + step_size.0
                point.i + step_size.1 }

To make this compatible with the code you already got...

