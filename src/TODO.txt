THE birb2bmp TOOL
=================

  - load a birb from file <- args_parser variant
  - split it into thread slices <- unsafe
  - find the largest number from the birb in parallel

  - what's the best approach to create the bitmap...?
     - single threadedly just compute
     - multi threaded: replace all the numbers in the birb with their 256 mapped counterparts?, then either use linear write or a mutex or something...
     - multi threaded: separate tinier bitmaps to merge into one larger one?    <- Can you do that?
     - multi threaded: one large bitmap with unsafe mutable concurrent slicing? <- Can you do that? This would be the BEST


=====================================
FIX ALL THE TODOS THAT ARE EVERYWHERE
=====================================

Adding the actual mathematics into the math module...
=====================================================

Args_Parser
===========

  - help text, that shows the flags, their args and the default values


Write_Back
==========

  - inside lib:: we'll have functions to do all of this...
  	- literally just lib::write_back(orbit:&Vec<u64>, supreme:&mut MutexLock)
        - Vec<u64>::with_capacity() and init counters to 0

  - vec[(imaginairy / step_size).floor() + (real / step_size).floor()] += 1


Logging output
==============

  - Add some grind-down logic, that properly empties the message queue on each cycle of the logging() function,
    so we don't get any funny business, when we want to add a little bit of sleep time between iterations...
    (And explain in the comments, why this is good to have, even though not expressly necessary given the immense
    computational intensity of the Buddahbrot set)

  - after whole operation is done, before shutdown yield another log-message with the final data, and the filename,
    that was written and whatnot.
