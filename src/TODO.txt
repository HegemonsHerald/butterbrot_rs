THE birb2bmp TOOL
=================

  - load a birb from file <- args_parser variant
  - split it into thread slices <- unsafe
  - find the largest number from the birb in parallel

  - what's the best approach to create the bitmap...?
     - single threadedly just compute
     - multi threaded: replace all the numbers in the birb with their 256 mapped counterparts?, then either use linear write or a mutex or something...
     - multi threaded: separate tinier bitmaps to merge into one larger one?    <- Can you do that?
     - multi threaded: one large bitmap with unsafe mutable concurrent slicing? <- Can you do that? This would be the BEST


=====================================
FIX ALL THE TODOS THAT ARE EVERYWHERE
=====================================

  - make the defaults and the help text align

Adding the actual mathematics into the math module...
=====================================================

  - when finding the samples do a preliminairy check with 1000 iterations, to immediately discard
    numbers from the mandelbrot set
  - before returning from next() in mh_orbits I have to check, that the orbit isn't inside the
    mandelbrot set. If it is, this is the second situation for having to rechoose the sample
  - have next() randomly try choosing a completely random sample, by having ::from_sample() randomly
    return a random sample


  - check the last point using something like this:

      let o =
      orbit.enumerate()
           .filter(| (i, c) | {

	      if i+1 == orbit_length { return true }

	      MHOrbits::in_range(c)

	   }).collect()

      /* check for mandelbrottedness */

      if MHOrbits::in_range(o[o.len()-1]) { o.pop() }

    This way we still get the benefit of doing it all in one go, without having to allocate
    the entire bloody orbit multiple times!

    IT'S VERY IMPORTANT TO REMOVE THE LAST POINT OF THE ORBIT WHEN DOING THIS!


Args_Parser
===========

Consider allowing for the (as it seems) common input mode:

provide an anchor point, width, height and a zoom factor.

The inverse of the zoom factor is the step_size, so you can just go:

step_size = (1/zoom, 1/zoom)
other_point = { point.r + step_size.0
                point.i + step_size.1 }

To make this compatible with the code you already got...

