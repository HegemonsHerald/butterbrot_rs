
=====================================
FIX ALL THE TODOS THAT ARE EVERYWHERE
=====================================

Adding the actual mathematics into the math module...
=====================================================

Args_Parser
===========

  - help text, that shows the flags, their args and the default values


Write_Back
==========

  - inside lib:: we'll have functions to do all of this...
  	- literally just lib::write_back(orbit:&Vec<u64>, supreme:&mut MutexLock)
        - Vec<u64>::with_capacity() and init counters to 0

  - vec[(imaginairy / step_size).floor() + (real / step_size).floor()] += 1


Termination Settings
====================

  - you specify the number of samples to compute

  - you optionally specify a timeout after which the program will definitely terminate, whether it's done or not

  - if you only specify a timeout, the args_parser sets the sample number to integer_max so that as many samples
    as possible will be computed

  - if you don't specify a timeout, the args_parser doesn't set the timeout flag, so the timeout will be ignored

    let (timeout, runtime, samples) = args_parser(args_v);

    where timeout = true if timeout setting was specified
	  runtime = the number of seconds (?) to terminate after, if timeout is true
	  samples = the number of samples to compute


Logging output
==============

  - main keeps a receiver of a channel
  - main keeps a stopwatch running, about the elapsed time
  - each thread gets a sender to that receiver

  - after each write_back the threads send a tuple with the thread's unique id and the number of samples left in it's MHOrbits-Iterator

  - main keeps a list of messages as long as the number of threads there is
  - every time main receives a message, it puts the number of samples into the id-position of the thread in the messages list
  - every time each position of the list is filled, main empties the message queue and produces following logging-output:

        ( some four or so newlines, so that there's space above! )


      Width: NNNN           Height: NNNN
      Iterations: NNNN      Samples: NNNN
      Complex1 { r: FF, i: FF }
      Complex2 { r: FF, i: FF }
      Filename: BIRB

      thread 1 { total: NN, done: NN, left: NN, percent: NN% }
      thread 2 { total: NN, done: NN, left: NN, percent: NN% }
      thread 3 { total: NN, done: NN, left: NN, percent: NN% }
      thread 4 { total: NN, done: NN, left: NN, percent: NN% }
      thread 5 { total: NN, done: NN, left: NN, percent: NN% }
      thread 6 { total: NN, done: NN, left: NN, percent: NN% }
      thread 7 { total: NN, done: NN, left: NN, percent: NN% }
      thread 8 { total: NN, done: NN, left: NN, percent: NN% }

      samples done / total:   NN/NN
      percentage done:	      NN%
      time elapsed:	      NNs
      left / maximum runtime: NNs / NNs  ( this will be ridiculous if no to is provided =) )

  - for the settings at the top, you can probably be smart and create some function, that produces this output once, and then you can just keep it!!!!
    note that this uses the fancy ass indentation you figured out for the jdoc stuff as well: which is longer, width or iterations? and then add spaces
    and a tab after them to align them

  - the percentages can easily be computed from main, cause main knows how many samples each thread has to work on from originally creating the threads

  - the logging function only empties those msg from its queue, that don't contain the count 0, and when all counts are 0, it returns! (or after the timeout has elapsed)

  - after whole operation is done, before shutdown yield another log-message with the final data, and the filename,
    that was written and whatnot.
